{
"version":3,
"file":"module$node_modules$$codemirror$rangeset$dist$index_cjs.js",
"lineCount":31,
"mappings":"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",
"sources":["node_modules/@codemirror/rangeset/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$$codemirror$rangeset$dist$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar state = require('@codemirror/state');\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = state.MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n    findIndex(pos, end, side = end * 1000000000 /* Far */, startAt = 0) {\n        if (pos <= 0)\n            return startAt;\n        let arr = end < 0 ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer = RangeSet.empty, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this.isEmpty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this.isEmpty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.length == 0 || this.isEmpty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this.isEmpty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    @internal\n    */\n    get isEmpty() { return this.nextLayer == this; }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            !set.isEmpty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            !set.isEmpty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n    static eq(oldSets, newSets, from = 0, to) {\n        if (to == null)\n            to = 1000000000 /* Far */;\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length)\n            return false;\n        if (!a.length)\n            return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for (;;) {\n            if (sideA.to != sideB.to ||\n                !sameValues(sideA.active, sideB.active) ||\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\n                return false;\n            if (sideA.to >= to)\n                return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < 500 /* BigPointSize */)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n        if (!forward || this.rangeIndex < rangeIndex)\n            this.rangeIndex = rangeIndex;\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                if (++this.rangeIndex == chunk.value.length) {\n                    this.chunkIndex++;\n                    if (this.skip) {\n                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                            this.chunkIndex++;\n                    }\n                    this.rangeIndex = 0;\n                }\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = this.active.length - 1; i >= 0; i--) {\n            if (this.activeRank[i] < this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexports.Range = Range;\nexports.RangeSet = RangeSet;\nexports.RangeSetBuilder = RangeSetBuilder;\nexports.RangeValue = RangeValue;\n\n};"],
"names":["shadow$provide","global","require","module","exports","cmpRange","a","b","from","value","startSide","findSharedChunks","inA","Map","set","i","chunk","length","maxPoint","chunkPos","shared","Set","get","add","heapBubble","heap","index","cur","childIndex","child","compare","startA","startB","comparator","goto","endB","pos","dPos","diff","to","endSide","end","clipEnd","Math","min","point","eq","comparePoint","sameValues","active","compareRange","next","remove","array","e","pop","insert","findMinIndex","found","foundPos","Object","defineProperty","state","RangeValue","other","range","Range","prototype","mapMode","MapMode","TrackDel","constructor","Chunk","findIndex","side","startAt","arr","lo","hi","mid","between","offset","f","undefined","map","changes","newPos","val","curFrom","curTo","mapped","mapPos","newFrom","newTo","max","push","RangeSet","nextLayer","empty","last","chunkEnd","isEmpty","size","update","updateSpec","sort","filterFrom","filterTo","filter","slice","of","LayerCursor","spill","builder","RangeSetBuilder","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","finishInner","chunks","start","touch","touchesRange","iter","HeapCursor","sets","oldSets","newSets","textDiff","minPointSize","indexOf","sharedChunks","sideA","SpanCursor","sideB","iterGaps","fromA","fromB","spans","iterator","cursor","open","openStart","activeForPoint","openEnd","span","ranges","build","finish","chunkStart","lastTo","lastFrom","setMaxPoint","finishChunk","newArrays","Error","result","layer","skip","minPoint","rank","gotoInner","forward","has","top","activeTo","activeRank","minActive","pointRank","pointFrom","removeActive","addActive","trackOpen","wasPoint","trackExtra","nextVal","reverse"]
}
