{"version":3,"sources":["bfuncs/parsing.cljs"],"mappings":"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","names":["bfuncs.parsing/parse-token","tok","clojure.string/blank?","clojure.string/ends-with?","clojure.string/replace","bfuncs.parsing/parse-input","type","input-str","iter__4529__auto__","s__67473","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4527__auto__","size__4528__auto__","cljs.core/count","b__67475","cljs.core/chunk-buffer","i__67474","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__67472","cljs.core/chunk-rest","cljs.core/first","cljs.core/cons","cljs.core/rest","line","clojure.string.split","cljs.core.into","cljs.core.map","var_args","G__67481","bfuncs.parsing/walk-with","js/Error","f","expr","G__67482","bfuncs.utils.hiccup_tag","cljs.core/second","x","G__67483","G__67484","bfuncs.parsing/->infix","tree","cljs.core/vector?","G__67485","G__67487","cljs.core/vec","cljs.core.interpose","bfuncs.parsing/->infix-string","G__67491","cljs.core/name","temp__27540__auto__","G__67492","cljs.core/Keyword","head","G__67494","G__67497","bfuncs.utils.str_join","bfuncs.parsing/echo-infix","cljs.core.println","bfuncs.parsing/parse-or-test","bfuncs.parsing/parse-and-test","bfuncs.parsing/parse-xor-test","bfuncs.parsing/parse-xand-test","bfuncs.parsing/parse-true-test","bfuncs.parsing/parse-false-test","bfuncs.parsing/parse-not-test","bfuncs.parsing/invalid-char","cljs.core/re-find","bfuncs.parsing/digit-string?","cljs.core/boolean","cljs.core/re-matches","bfuncs.parsing/invalid-variable-name","bfuncs.parsing/parse-bool","pred__67505","expr__67506","G__67508","G__67509","G__67510","G__67511","G__67517","bfuncs.parsing/operation-operands","bfuncs.parsing.operation_operands","sort?","temp__5737__auto__","op","bfuncs.data/operation","G__67527","bfuncs.data/operands","cljs.core.sort","bfuncs.data/compare-bobj","cljs.core/array?","cljs.core.keyword","obj67518","k67519","obj67520","applied-science.js-interop.impl/in?*","js/undefined","cljs.core._EQ_","G__67521","bfuncs.utils/array-like?","G__67523","cljs.core/next","bfuncs.parsing/get-operation","or__4126__auto__","t","G__67529","G__67533","fexpr__67532","bfuncs.parsing/digits","G__67539","bfuncs.parsing/parse-minterms","string","bfuncs.parsing.parse_minterms","opts","cljs.core.partial","js/parseInt","G__67541","bfuncs.parsing/bobj->bexpr","bobj","bfuncs.parsing.bobj__GT_bexpr","cljs.core/str","vf","temp__5733__auto__","go","r","cljs.core/boolean?","G__67544","bfuncs.parsing/bexpr->bobj","bexpr","bfuncs.parsing.bexpr__GT_bobj","cljs.core/identity","G__67548","G__67549","bfuncs.algebra.operator","cljs.core.apply","G__67554","G__67560","bfuncs.parsing/xor","args-arr__4757__auto__","len__4736__auto__","i__4737__auto__","argseq__4758__auto__","cljs.core/IndexedSeq","seq67558","G__67559","self__4723__auto__","more","cljs.core/odd?","p1__67556#","p2__67555#","cljs.core.reduce","G__67567","bfuncs.parsing/xand","seq67565","G__67566","cljs.core/not","cljs.core/even?","p1__67563#","p2__67562#","bfuncs.parsing/->bfn","boperators","vars","cljs.core.atom","cljs.core/sorted-set","vec__67576","cljs.core.nth","operands","G__67579","v","cljs.core.symbol","cljs.core.swap_BANG_","cljs.core/conj","cljs.core.list_STAR_","cljs.core.doall","precpt","vv","cljs.core/deref","ef","cljs.core/List","bfuncs.parsing/->fn","var-map","cljs.core/zipmap","p1__67583#","cljs.core.range","body","bfuncs.parsing.walk_with","vec__67587","G__67590","G__67591","fexpr__67592","fexpr__67593","js/Function","cljs.core/val","bfuncs.parsing/pr-body","sb","js/goog.string.StringBuffer","writer","cljs.core/StringBufferWriter","eq?","start","x1","mid","x2","end","cljs.core/-write","vec__67611","G__67614","G__67616","cljs.core/pr-sequential-writer","G__67617","G__67618","cljs.core/reset!","G__67619","pr-binop","bfuncs.parsing/->js-fn","p1__67620#","bfuncs.parsing/->bytes","js/module$bfuncs$jsUtils.functionBytes","bfuncs.parsing/->js-fn-strs","p1__67621#","bfuncs.parsing/variables","cljs.core/transient","vec__67622","G__67625","cljs.core/conj!","cljs.core/run!","cljs.core/persistent!","bfuncs.parsing/js->bobj","G__67626","cljs.core.js__GT_clj","bfuncs.parsing/js->bobj-and-vars","as-var","G__67627","cljs.core/chunk-first"],"sourcesContent":["(ns bfuncs.parsing\r\n  (:require [bfuncs.utils :as util\r\n             :refer [singleton? echo hiccup-tag let-case array-like? parser-spec map-reduce rrange str-join echol]]\r\n            [clojure.string :as str]\r\n            [applied-science.js-interop :as j]\r\n            [bfuncs.algebra :refer [operator || && ! !|| !&& <+> <*> <=> ==> !==> <== !<==]]\r\n            [bfuncs.data :refer [operation operands compare-bobj]]\r\n            [\"/bfuncs/jsUtils\" :refer [functionBytes]])\r\n  (:import [goog.string StringBuffer]))\r\n\r\n(defn parse-token\r\n  [tok]\r\n  (when-not (str/blank? tok)\r\n    (if (str/ends-with? tok \"'\")\r\n      [(str/replace tok #\"'$\" \"\") false]\r\n      [tok true])))\r\n\r\n(defn parse-input\r\n  \"Returns a sequence of maps, one for each line in input-str. Each map is\r\n  keyed by the variable names that appear in that line, which have value false if\r\n  that variable ends with ', and true if not.\"\r\n  [type input-str]\r\n  (for [line (str/split input-str #\"\\s*[+\\n]\\s*\")\r\n        :when (not (str/blank? line))]\r\n    (into {}\r\n          (map parse-token)\r\n          (str/split line #\"\\s+\"))))\r\n\r\n(defn- walk-with\r\n  ([f expr]\r\n   (f (if (hiccup-tag :expr expr)\r\n        (second expr)\r\n        expr)))\r\n  ([f x expr]\r\n   (f x (if (hiccup-tag :expr expr)\r\n          (second expr)\r\n          expr))))\r\n\r\n(defn ->infix [tree]\r\n  (if-not (vector? tree)\r\n    tree\r\n    (case (count tree)\r\n      (0 1) tree\r\n      2 [(first tree) (->infix (second tree))]\r\n      (vec (interpose (first tree)\r\n                      (map ->infix (rest tree)))))))\r\n(defn ->infix-string [tree]\r\n  (if-not (vector? tree)\r\n    (str tree)\r\n    (case (count tree)\r\n      0 (str tree)\r\n      1 (name (first tree))\r\n      2 (let-case [head (first tree)]\r\n          (:var :expr) (recur (second tree))\r\n          :NOT (str \"!\" (->infix-string (second tree)))\r\n          (str (name head) \"(\" (->infix-string (second tree)) \")\"))\r\n      (str-join \"(\" (str \" \" (name (first tree)) \" \") \")\"\r\n                ->infix-string (rest tree)))))\r\n\r\n(defn echo-infix [tree]\r\n  (println (->infix-string tree))\r\n  tree)\r\n\r\n(def parse-or-test \"a+b|c||d\u22c1e\u2228f'or(g) OR h\")\r\n(def parse-and-test \"a b(c) d * e & f && g \u22c0(h)aNd(i)\u2227j and k\")\r\n(def parse-xor-test \"a xor b^(c)xor(d)\u2295e\u22bbf\")\r\n(def parse-xand-test \"a xand b EQ c=d xnoR e\")\r\n(def parse-true-test \"TRUE & true * 1 * \u22a4\")\r\n(def parse-false-test \"false & FALSE * 0 * \u22a5\")\r\n(def parse-not-test \"~a(b') NOT c & \u00ac!d\")\r\n\r\n(defn- invalid-char\r\n  [x] (re-find #\"[^\\w\\s+|\u22c1\u2228^\u2295\u22bb=\u2299*&\u22c0\u2227()'!~\u00ac\u22a4\u22a5]\" x))\r\n\r\n(defn- digit-string?\r\n  [x] (boolean (re-matches #\"\\d+\" x)))\r\n\r\n(defn- invalid-variable-name\r\n  [x] (re-find #\"^\\w+\" x))\r\n\r\n(defn- parse-bool [x]\r\n  (if (string? x)\r\n    (condp re-matches x\r\n      #\"(?i)false|0|\u22a5\" false\r\n      #\"(?i)true|1|\u22a4\" true\r\n      x)\r\n    x))\r\n\r\n(defn operation-operands\r\n  ([x] (operation-operands x false))\r\n  ([x sort?]\r\n   (if-some [op (operation x)]\r\n     [op (cond->> (operands x)\r\n           sort? (sort compare-bobj))]\r\n     (if-some [op (when (array? x) (keyword (j/get x :operation)))]\r\n       (if (= op :expr)\r\n         (recur (first x) sort?)\r\n         [op x])\r\n       (let-case [op (when (array-like? x)\r\n                       (keyword (first x)))]\r\n         :expr (recur (second x) sort?)\r\n         :var [op (rest x)]\r\n         nil (case (parse-bool x)\r\n               true [:TRUE nil]\r\n               false [:FALSE nil]\r\n               [:var [x]])\r\n         [op (next x)])))))\r\n\r\n(defn get-operation [expr]\r\n  (or (let [t (hiccup-tag expr)]\r\n        (if (= t :expr)\r\n          (get-operation (second expr))\r\n          t))\r\n      (operation expr)\r\n      ({true :TRUE false :FALSE} (parse-bool expr))\r\n      :var))\r\n\r\n(def ^string digits \"0123456789abcdefghijklmnopqrstuvwxyz\")\r\n\r\n(defn parse-minterms\r\n  ([string]\r\n   (parse-minterms string nil))\r\n  ([string opts]\r\n   (map (partial js/parseInt (if (:binary opts) 2 10))\r\n        (str/split string #\"[,\\s]+\"))))\r\n\r\n(defn bobj->bexpr\r\n  ([bobj] (bobj->bexpr bobj str))\r\n  ([bobj vf]\r\n   [:expr\r\n    ((fn go [bobj]\r\n       (if-let [op (operation bobj)]\r\n         (into [op] (map go) bobj)\r\n         (let [r (vf bobj)]\r\n           [(if (boolean? r) :bool :var) r])))\r\n     bobj)]))\r\n\r\n(defn bexpr->bobj\r\n  ([bexpr] (bexpr->bobj bexpr identity))\r\n  ([bexpr vf]\r\n   ((fn go [bexpr]\r\n      (let-case [op (-> bexpr first keyword)]\r\n        :expr (go (second bexpr))\r\n        :var (vf (second bexpr))\r\n        (if-let [f (operator op)]\r\n          (apply f (map go (rest bexpr)))\r\n    (vf (second bexpr)))))\r\n    bexpr)))\r\n\r\n(defn- xor\r\n  ([x] x)\r\n  ([x & more]\r\n   (odd?\r\n    (reduce #(if %2 (inc %1) %1)\r\n            (if x 1 0)\r\n            more))))\r\n\r\n(defn- xand\r\n  ([x] (not x))\r\n  ([x & more]\r\n   (even?\r\n    (reduce #(if %2 (inc %1) %1)\r\n            (if x 1 0)\r\n            more))))\r\n\r\n(defn ->bfn\r\n  [bobj]\r\n  (let [boperators {:AND 'and\r\n                    :OR 'or\r\n                    :NOT 'not\r\n                    :XNOR 'xand\r\n                    :XOR 'xor}\r\n        vars (atom (sorted-set))\r\n        go (fn go [x]\r\n             (let [[op operands] (operation-operands x)]\r\n               (case op\r\n                 :TRUE true\r\n                 :FALSE false\r\n                 :var (let [v (symbol (first operands))]\r\n                        (swap! vars conj v)\r\n                        v)\r\n                 (:AND :OR :XOR :XNOR :NOT) (list* (boperators op) (doall (map go operands))))))\r\n        precpt (go (if (hiccup-tag :expr bobj)\r\n                     (second bobj)\r\n                     bobj))\r\n        vv (vec @vars)\r\n        ef (list 'fn vv precpt)]\r\n    [vv ef #_(cjj/eval (empty-state)\r\n                       ef\r\n                       {:eval js-eval\r\n                        :context :expr}\r\n                       :value)]))\r\n\r\n(defn- ->fn [expr vars]\r\n  (let [var-map (zipmap vars (map #(str \"x\" %) (range)))\r\n        body (walk-with (fn go [x]\r\n                          (let [[op operands] (operation-operands x)]\r\n                            (case op\r\n                              :TRUE \"true\"\r\n                              :FALSE \"false\"\r\n                              :var (var-map (first operands))\r\n                              :NOT (str \"!(\" (go (first operands)) \")\")\r\n                              (:AND :OR) (str-join \"(\" ({:AND \" && \", :OR \" || \"} op) \")\"\r\n                                                   go operands)\r\n                              (:XOR :XNOR) (str-join ({:XOR \"(xor(\", :XNOR \"(!xor(\"} op) \",\" \"))\"\r\n                                                     go operands))))\r\n                        expr)]\r\n    (js/Function\r\n     (str-join \"[\" \",\" \"]\" val var-map)\r\n     (str \"const xor=(...xs)=>xs.reduce((a,b)=>(b===false||b===null)?a:!a,false);\r\n           return \"\r\n          body\r\n          \";\"))))\r\n\r\n(defn- pr-body [var-map expr]\r\n  (let [sb (StringBuffer.)\r\n        writer (new StringBufferWriter sb)\r\n        eq? (atom false)]\r\n    (letfn [(pr-binop [writer start x1 mid x2 end]\r\n              (do (-write writer start)\r\n                  (go x1 writer)\r\n                  (-write writer mid)\r\n                  (go x2 writer)\r\n                  (-write writer end)))\r\n            (go [x writer]\r\n              (let [[op operands] (operation-operands x)]\r\n                (case op\r\n                  :TRUE (-write writer \"true\")\r\n                  :FALSE (-write writer \"false\")\r\n                  :var (-write writer (var-map (first operands)))\r\n                  :NOT (do (-write writer \"!(\")\r\n                           (go (first operands) writer)\r\n                           (-write writer \")\"))\r\n                  (:AND :NAND\r\n                   :OR :NOR\r\n                   :XOR :XNOR) (pr-sequential-writer writer go\r\n                                                     (case op (:NOR :NAND) \"!(\" \"(\")\r\n                                                     (case op\r\n                                                       (:AND :NAND) \" && \"\r\n                                                       (:OR :NOR) \" || \"\r\n                                                       :XOR \" != \"\r\n                                                       :XNOR \" == \")\r\n                                                     \")\" nil operands)\r\n                  (:EQ :NEQ) (do (reset! eq? true)\r\n                                 (pr-sequential-writer writer go\r\n                                                       (case op :EQ \"eq(\" :NEQ \"!eq(\")\r\n                                                       \",\" \")\" nil operands))\r\n                  :IMP (pr-binop writer \"(!(\" (first operands) \") || \" (second operands) \")\")\r\n                  :NIMP (pr-binop writer \"(\" (first operands) \" && !(\" (second operands) \"))\")\r\n                  :CON (pr-binop writer \"(\" (first operands) \" || !(\" (second operands) \"))\")\r\n                  :NCON (pr-binop writer \"(!(\" (first operands) \") && \" (second operands) \")\"))))]\r\n      (-write writer \"return \")\r\n      (go expr writer)\r\n      (-write writer \";\")\r\n      (-flush writer)\r\n      (str (when @eq?\r\n             \"const eq = (x1, ...xs) => { for (const x of xs) if (x != x1) return false; return true; }; \")\r\n           sb))))\r\n\r\n(defn ->js-fn\r\n  ([vars expr]\r\n   (let [var-map (zipmap vars (map #(str \"x\" %) (range)))]\r\n     (js/Function\r\n      (str-join \"[\" \",\" \"]\" val var-map)\r\n      (pr-body var-map expr)))))\r\n\r\n(defn ->bytes\r\n  ([vars expr]\r\n   (functionBytes (->js-fn vars expr) (count vars))))\r\n\r\n(defn ->js-fn-strs\r\n  ([vars expr]\r\n   (let [var-map (zipmap vars (map #(str \"x\" %) (range)))]\r\n     [(str-join \"[\" \",\" \"]\" val var-map)\r\n      (pr-body var-map expr)]))\r\n  )\r\n\r\n(defn variables [expr]\r\n  (let [vars (atom (transient #{}))]\r\n    ((fn go [x]\r\n       (let [[op operands] (operation-operands x)]\r\n         (case op\r\n           :var (when-not\r\n                 (hiccup-tag :instaparse/failure\r\n                             (first operands))\r\n                  (swap! vars conj! (first operands)))\r\n           (:TRUE :FALSE :instaparse/failure) nil\r\n           (run! go operands))))\r\n     expr)\r\n    (vec (sort (persistent! @vars)))))\r\n\r\n(defn js->bobj [expr]\r\n  ((fn go [x]\r\n     (if (array? x)\r\n       (let-case [op (first x)]\r\n         \"expr\" (go (second x))\r\n         \"var\" (js->clj (second x))\r\n         (\"TRUE\" true) true\r\n         (\"FALSE\" false) false\r\n         (apply (operator (keyword op))\r\n                (map go (rest x))))\r\n       (js->clj x)))\r\n   expr))\r\n\r\n(defn js->bobj-and-vars [expr]\r\n  (let [vars (atom (transient #{}))\r\n        as-var (fn [x]\r\n                 (let [v (js->clj x)]\r\n                   (when-not (boolean? v)\r\n                     (swap! vars conj! v))\r\n                   v))]\r\n    [((fn go [x]\r\n        (if (array? x)\r\n          (let-case [op (first x)]\r\n            \"expr\" (go (second x))\r\n            \"var\" (as-var (second x))\r\n            (\"TRUE\" true) true\r\n            (\"FALSE\" false) false\r\n            (apply (operator (keyword op))\r\n                   (map go (rest x))))\r\n          (as-var x)))\r\n      expr)\r\n     (-> @vars persistent! sort vec)]))\r\n"]}