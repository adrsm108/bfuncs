{"version":3,"sources":["camel_snake_kebab/internals/string_separator.cljc"],"mappings":"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","names":["camel-snake-kebab$internals$string-separator$StringSeparator$split$dyn","x__4428__auto__","m__4429__auto__","camel-snake-kebab.internals.string-separator/split","goog/typeOf","m__4426__auto__","cljs.core/missing-protocol","camel-snake-kebab.internals.string-separator/StringSeparator","this","s","cljs.core/PROTOCOL_SENTINEL","goog.object/set","js/RegExp","clojure.string.split","camel-snake-kebab.internals.string-separator/classify-char","c","G__39991","camel-snake-kebab.internals.string-separator/generic-split","ss","cs","cljs.core.mapv","ss-length","result","cljs.core/transient","start","current","next","result+new","end","cljs.core.conj_BANG_","or__4126__auto__","cljs.core/seq","cljs.core/persistent!","cljs.core._EQ_","cljs.core.nth","vec__40003","a","b","cljs.core.subvec","cljs.core.not_EQ_","camel-snake-kebab.internals.string-separator/generic-separator","js/camel-snake-kebab","js/camel-snake-kebab.internals","js/camel-snake-kebab.internals.string-separator","js/camel-snake-kebab.internals.string-separator.t_camel_snake_kebab$internals$string_separator40014","camel-snake-kebab.internals.string-separator/t_camel_snake_kebab$internals$string_separator40014","_40016","meta40015","this__4369__auto__","writer__4370__auto__","opt__4371__auto__","cljs.core/-write","camel-snake-kebab.internals.string-separator/->t_camel_snake_kebab$internals$string_separator40014","_"],"sourcesContent":["(ns ^:no-doc camel-snake-kebab.internals.string-separator\n  (:require [clojure.string :as string])\n  #?(:clj (:import (java.util.regex Pattern))))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defprotocol StringSeparator\n  (split [this s] \": StringSeparator -> String -> NonEmptySeq[String]\"))\n\n#?(:clj\n   (letfn [(split-by-pattern [^Pattern p, ^String s]\n             (string/split s p))\n           ;; These could be optimized e.g. by using StringUtils in Apache Commons:\n           (split-by-string [^String p, ^String s]\n             (split-by-pattern (-> p Pattern/quote Pattern/compile) s))\n           (split-by-char [^Character p, ^String s]\n             (split-by-string (String/valueOf p) s))]\n     (extend Pattern   StringSeparator {:split split-by-pattern})\n     (extend String    StringSeparator {:split split-by-string})\n     (extend Character StringSeparator {:split split-by-char}))\n\n   :cljs\n   (extend-protocol StringSeparator\n     ;; Notes:\n     ;; * Characters are just strings in ClojureScript.\n     ;; * Using js/RegExp generates a warning, but what's the right way?\n\n     js/RegExp\n     (split [this s] (string/split s this))\n\n     string\n     (split [this s] (string/split s this))))\n\n(defn classify-char [c]\n  (case c\n    (\\0 \\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9) :number\n    (\\- \\_ \\space \\tab \\newline \\o013 \\formfeed \\return) :whitespace\n    (\\a \\b \\c \\d \\e \\f \\g \\h \\i \\j \\k \\l \\m \\n \\o \\p \\q \\r \\s \\t \\u \\v \\w \\x \\y \\z) :lower\n    (\\A \\B \\C \\D \\E \\F \\G \\H \\I \\J \\K \\L \\M \\N \\O \\P \\Q \\R \\S \\T \\U \\V \\W \\X \\Y \\Z) :upper\n    :other))\n\n(defn generic-split [ss]\n  (let [cs (mapv classify-char ss)\n        ss-length #?(:clj (.length ^String ss)\n                     :cljs (.-length ss))]\n    (loop [result (transient []), start 0, current 0]\n      (let [next (inc current)\n            result+new (fn [end]\n                         (if (> end start)\n                           (conj! result (.substring ^String ss start end))\n                           result))]\n        (cond (>= current ss-length)\n              (or (seq (persistent! (result+new current)))\n                  ;; Return this instead of an empty seq:\n                  [\"\"])\n\n              (= (nth cs current) :whitespace)\n              (recur (result+new current) next next)\n\n              (let [[a b c] (subvec cs current)]\n                ;; This expression is not pretty,\n                ;; but it compiles down to sane JavaScript.\n                (or (and (not= a :upper)  (= b :upper))\n                    (and (not= a :number) (= b :number))\n                    (and (= a :upper) (= b :upper) (= c :lower))))\n              (recur (result+new next) next next)\n\n              :else\n              (recur result start next))))))\n\n(def generic-separator\n  (reify StringSeparator\n    (split [_ s] (generic-split s))))\n"]}